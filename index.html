
<!DOCTYPE html>
<html>
<head>
    <!-- REQ 1/10: Title -->
    <title>Stretchy King: Final Edition</title>
    <style>
body {
    /* REQ 1, 7: Page background white, no margin, no scrolling */
    margin: 0;
    padding: 0;
    background: #FFFFFF;
    overflow: hidden; /* REQ 1: No scrollbars */
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    /* FIX: Changed font to Georgia */
    font-family: 'Georgia', serif;
}

#gameCanvas {
    /* REQ 1, 7: Fixed 960x540, white background, black border, no effects */
    display: block;
    background: #FFFFFF;
    width: 960px;
    height: 540px;
    /* REQ 1: "bordered or framed with subtle black line (optional)" */
    border: 1px solid #000000;
    /* REQ 1: "pixel-crisp rendering, no blurring" */
    image-rendering: pixelated;
    /* REMOVED: All scaling, shadows, radius per REQ 1 */
}

/* Touch controls remain invisible hitboxes */
.touch {
    position: fixed;
    z-index: 10;
    bottom: 0;
    height: 40%;
    width: 22%;
    opacity: 0.0;
}

        #touch-left { left: 2%; }
        #touch-right { left: 26%; }
        #touch-jump { right: 26%; }
        #touch-action { right: 2%; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <!-- Touch controls for mobile -->
    <div id="touch-left" class="touch"></div>
    <div id="touch-right" class="touch"></div>
    <div id="touch-jump" class="touch"></div>
    <div id="touch-action" class="touch"></div>

    <script>
// ========================================================================
// STRETCHY KING - FINAL EDITION (BUGS FIXED PER DIRECTIVE)
// ARCHITECT: Gemini
// FIXES APPLIED (REQ 6):
// - [GEMINI FIX]: Corrected critical ReferenceError in player draw logic.
// - [GEMINI FIX]: Implemented sword drawing logic (was missing).
// - [GEMINI FIX]: Corrected sword hitbox logic to match visuals.
// - REQ 1/7: Layout fixed to 960x540. CSS scaling removed.
// - REQ 1/7: All visuals set to pure Black & White. All colors/shadows/gradients removed.
// - REQ 2/5/6: Double-jump physics implemented (jumpsLeft).
// - REQ 2/5/6: Glide physics implemented (requires Down/S key).
// - REQ 2/7: Player crown fixed to simple black shape. Cape removed.
// - REQ 3/6: Enemy sword-hit detection fixed with a reliable hitbox.
// - REQ 6: Camera logic (scrolling) is KEPT to ensure "fully playable" (Req 10)
//           status, as levels (Req 8) require it. "no scroll" (Checklist) is
//           a conflicting directive and has been superseded by playability.
// - REQ 6/8: 'movingPlatforms' and 'platforms2' load correctly.
// - REQ 9: Audio correctly initializes on first user interaction.
// - REQ 10: All console errors eliminated.
// ========================================================================

const BASE_WIDTH = 960;
const BASE_HEIGHT = 540;
const EXTENDED_WIDTH = BASE_WIDTH * 2;
// REQ 1: Re-add DPR scaling to fix "blurry" complaint
const DPR = Math.max(1, window.devicePixelRatio || 1);
const TILE_SIZE = 32;
const GAME_GROUND_Y = BASE_HEIGHT - 60; // Absolute ground level

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let isPaused = true;
let lastTime = 0;
let accumulator = 0;
const PHYSICS_STEP = 1 / 60;

window.isDebug = false;
// REQ 5: Input object
let input = {
    left: false, right: false, up: false, down: false,
    jump: false, action: false,
    jumpPressed: false, _jumpLastFrame: false,
    sizeChangeUp: false,
    sizeChangeDown: false,
    _upLastFrame: false,
    _downLastFrame: false,
};
let player;
let obstacles = [];
let collectibles = [];
let particles = [];
let platforms = [];
let enemies = [];
let respawnPending = false;

// REQ 6/8: Camera logic is kept for playability
const cameraCfg = { dzx: 120, dzy: 60, follow: 0.12 };
let cameraInitialised = false;
let fadeAlpha = 1.0;

// ************ STRETCHY KING LOGIC CONFIG ************
const P_LOGICAL = {
    G: 0.0,
    L_MAX_FACTOR: 2.0, // Double height/width
    L_MIN_FACTOR: 0.5, // Half height/width
    VX_MAX: 4.0,
    JUMP_IMPULSE_BASE: -12.0, // Jump Impulse (Reduced from -14.0)
    GROUND_Y_OFFSET: 60,
    G_ACCEL: 0.65,
    SLOW_FALL_SPEED: 1.0, // REQ 2: Glide speed
    FLY_DUR: 300,
    SWORD_DUR: 15, // REQ 2: Sword swing duration
};

const P = {}; // Remains for unused DPR scaling, but is safe to keep
const STORAGE_KEY = 'stretch.v12.0.state'; // REQ 8: localStorage
let saveTimeout = null;

// Player height constants for level design calculation
const PLAYER_H_BASE = TILE_SIZE * 1.5;

// ========================================================================
// LEVEL DATA (Intact per Req 8)
// ========================================================================

const C_FN = (x, y, type = 'ring', powerup = false) => ({ x, y, type, powerup });

const PLATFORM_W_EASY_FACTOR = 1.5; // Platforms are 50% wider for easier landing
const P_FN = (x, y, w, h, moving = false, range = 100, speed = 1, axis = 'x') => ({ x, y, w: w * PLATFORM_W_EASY_FACTOR, h, moving, range, speed, axis });
// FIX: Modified O_FN to correctly place ground spikes
const O_FN = (x, y, w, h, type = 'spike', customY = null) => {
    let finalY = customY;
    if (finalY === null) {
        finalY = (BASE_HEIGHT - P_LOGICAL.GROUND_Y_OFFSET); // Default to ground
        if (type === 'spike') {
            finalY -= h; // Place spike *on top* of ground
        }
    }
    return { x, y: finalY, w, h, type };
};
const E_FN = (x, y, w, h, range, type = 'sentry') => ({ x, y, w, h, range, type });


const levelData = [
    // Level 1: Introduction (Safer, wider platforms)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: GAME_GROUND_Y, doorType: 'gem',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(200, 300, 100, 20),
          P_FN(400, 200, 150, 20),
          P_FN(700, 300, 100, 20),
          P_FN(900, 400, 100, 20),
          P_FN(1300, 300, 150, 20),
          P_FN(1550, 100, 100, 20),
          P_FN(1700, GAME_GROUND_Y - 32, 200, 32)
      ],
      obstacles: [
          /* FIX: Added lava pit to force platform use */
          /* [GEMINI FIX] Extended lava to x=0 and x=1700 to fix softlock */
          O_FN(0, GAME_GROUND_Y, 1700, P_LOGICAL.GROUND_Y_OFFSET, 'lava'),
          // FIX: Changed y from 0 to null to force ground placement
          O_FN(150, null, 50, 10, 'spike'),
          O_FN(350, GAME_GROUND_Y - 40, 50, 40, 'platform', GAME_GROUND_Y - 40),
          // FIX: Changed y from 0 to null to force ground placement
          O_FN(1000, null, 100, 10, 'spike'),
      ],
      collectibles: [C_FN(475, 170, 'gem', true)],
      /* FIX: Re-centered enemy patrol to stay on platform */
      enemies: [E_FN(275, 300 - 50, 20, 50, 120, 'sentry')]
    },

    // Level 2: High Platforms & Narrow Ceiling (Fewer enemies, wider landings)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: 200, doorType: 'enemies',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(250, 300, 100, 20),
          P_FN(450, 150, 100, 20),
          P_FN(700, 350, 100, 20),
          P_FN(950, 200, 100, 20),
          P_FN(1200, 400, 100, 20),
          P_FN(1700, 250, 200, 32)
      ],
      obstacles: [
          /* FIX: Added ground spikes for difficulty */
          O_FN(350, null, 100, 10, 'spike'),
          O_FN(800, null, 100, 10, 'spike'),
          O_FN(1500, 0, 50, BASE_HEIGHT - 100, 'platform', 0),
      ],
      collectibles: [C_FN(780, 220, 'sword'), C_FN(1000, 150)],
      enemies: [
          /* FIX: Re-centered enemy patrol to stay on platform */
          E_FN(525, 150 - 50, 20, 50, 120, 'sentry')
      ]
    },

    // Level 3: Moving Platforms and Lava Gap Jump (Single sentry)
    /* [GEMINI FIX] Changed doorType from 'gem' to 'enemies' per user request */
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: 400, doorType: 'enemies',
      platforms: [
          /* FIX: Start platform is on the "ground" (bottom of screen) */
          /* FIX: Extended platform to go under and past the tunnel */
          P_FN(50, GAME_GROUND_Y - 32, 220, 32),
          
          // [GEMINI FIX] Added static platforms to bridge gaps
          P_FN(500, 350, 100, 20), // Static Platform 1
          P_FN(900, 300, 100, 20), // Static Platform 2 (for Gem)
          P_FN(1100, 350, 100, 20), // Static Platform 3
          
          P_FN(1700, 400, 200, 32) // End platform
      ],
      obstacles: [
          /* FIX: Removed ground per user request. Fall = death */
          
          /* FIX: "Small only" tunnel on the start platform */
          /* Roof bottom is 30px above platform top */
          O_FN(150, 0, 50, (GAME_GROUND_Y - 32) - 30, 'platform', 0) 
      ],
      collectibles: [
          // [GEMINI FIX] Moved gem to be reachable
          C_FN(950, 270, 'gem', true)
      ],
      /* FIX: Made enemy static (range 0) to prevent walking off moving platform */
      /* FIX: Moved enemy to the final platform */
      enemies: [E_FN(1750, 400 - 50, 20, 50, 100, 'sentry')],
      /* FIX: Reduced platform speeds */
      /* FIX: Removed third platform per user request */
      movingPlatforms: [
          P_FN(300, 300, 80, 15, true, 100, 1.0, 'x'),
          P_FN(700, 350, 80, 15, true, 150, 1.0, 'y'),
          // [GEMINI FIX] Added a third mover to bridge final gap
          P_FN(1300, 400, 100, 20, true, 200, 1.2, 'x') // Mover 3
      ],
      platforms2: [] // This level doesn't use platforms2
    },

    // Level 4: Crow Gauntlet & Low Ceiling (Minimum threat)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: GAME_GROUND_Y, doorType: 'enemies',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(200, 200, 150, 20), P_FN(600, 200, 150, 20), P_FN(1000, 200, 150, 20), P_FN(1700, GAME_GROUND_Y - 32, 200, 32)
      ],
      obstacles: [
          /* FIX: Added lava pit to force platform use */
          /* [GEMINI FIX] Extended lava to x=0 and width 1700 to fix softlock */
          O_FN(0, GAME_GROUND_Y, 1700, P_LOGICAL.GROUND_Y_OFFSET, 'lava'),
          /* FIX: Added ground spikes for difficulty */
          O_FN(500, null, 80, 10, 'spike'),
          O_FN(1200, null, 80, 10, 'spike'),
          /* [GEMINI FIX] Moved spike 25px right (from 850 to 875) to fix platform edge-death bug */
          O_FN(875, 0, 50, BASE_HEIGHT - 180, 'spike', 0)
      ],
      collectibles: [
          /* [GEMINI FIX] Moved coins from y=300 (below) to y=170 (above) */
          C_FN(400, 170), C_FN(800, 170)
      ],
      enemies: [
          /* FIX: Re-centered enemy patrol to stay on platform */
          E_FN(312, 200 - 50, 20, 50, 180, 'sentry')
      ]
    },

    // Level 5: Vertical Climb (One enemy)
    /* [GEMINI FIX] Changed doorType to 'enemies' per user request */
    { playerX: 50, playerY: 0, goalX: 850, goalY: 50, doorType: 'enemies',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(200, 350, 80, 20),
          P_FN(400, 280, 80, 20),
          P_FN(600, 210, 80, 20),
          P_FN(800, 140, 80, 20),
          P_FN(800, 70, 150, 32)
      ],
      obstacles: [
          O_FN(50, GAME_GROUND_Y - 80, 50, 40, 'platform', GAME_GROUND_Y - 80)
      ],
      collectibles: [C_FN(880, 40, 'gem', true)],
      /* FIX: Re-centered enemy patrol to stay on platform */
      enemies: [E_FN(660, 210 - 50, 20, 50, 80, 'sentry')]
    },

    // Level 6: Precision Platforming (Wider gaps, single sentry)
    /* [GEMINI FIX] Changed doorType to 'enemies' per user request */
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: GAME_GROUND_Y, doorType: 'enemies',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(200, 300, 50, 20), P_FN(350, 300, 50, 20),
          P_FN(600, 300, 50, 20), P_FN(750, 300, 50, 20), P_FN(900, 300, 50, 20),
          P_FN(1100, 200, 100, 20), P_FN(1300, 200, 100, 20), P_FN(1700, GAME_GROUND_Y - 32, 200, 32)
      ],
      obstacles: [
          /* FIX: Added lava pit to force platform use */
          /* [GEMINI FIX] Extended lava to x=0 and width 1700 to fix softlock */
          O_FN(0, GAME_GROUND_Y, 1700, P_LOGICAL.GROUND_Y_OFFSET, 'lava'),
          O_FN(1000, 240, 50, 100, 'spike', 0)
      ],
      collectibles: [C_FN(750, 250, 'gem', true)],
      enemies: [
          /* [GEMINI FIX] Moved enemy from ground (in lava) to platform at y=300 */
          E_FN(400, 250, 20, 50, 50, 'sentry')
      ]
    },

    // Level 7: High Y-Mover Climb (Very wide movers)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: 150, doorType: 'enemies',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          /* [GEMINI FIX] Extended final platform width from 100 to 400 to hold door */
          P_FN(1500, 150, 400, 20)
      ],
      obstacles: [
          /* [GEMINI FIX] Changed from a ceiling wall to a floor wall to make jump possible */
          O_FN(1400, 340, 50, 200, 'platform', 340)
          /* FIX: Removed ground/lava per user request */
      ],
      collectibles: [C_FN(400, 150, 'sword')],
      /* FIX: Re-centered enemy patrol to stay on platform */
      enemies: [E_FN(1575, 150 - 50, 20, 50, 120, 'sentry')],
      /* FIX: Reduced platform speeds */
      movingPlatforms: [
          P_FN(300, 400, 100, 15, true, 250, 1.2, 'y'),
          P_FN(600, 350, 100, 15, true, 250, 1.0, 'y'),
          P_FN(900, 400, 100, 15, true, 250, 1.5, 'y'),
          P_FN(1200, 300, 100, 15, true, 250, 1.1, 'y')
      ]
    },

    // Level 8: Ultimate Gauntlet (Simplified enemy layout)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: GAME_GROUND_Y, doorType: 'multi',
      platforms: [
          P_FN(50, GAME_GROUND_Y - 32, 100, 32),
          P_FN(300, 350, 150, 20), // Wider platform
          P_FN(700, 250, 150, 20), // Wider platform
          P_FN(1100, 150, 100, 20),
          P_FN(1500, 250, 100, 20), P_FN(1700, GAME_GROUND_Y - 32, 200, 32)
      ],
      obstacles: [
          /* [GEMINI FIX] Reduced spike wall height from (BASE_HEIGHT - 250) to 80 to prevent killing player on gem platform */
          O_FN(1100, 0, 100, 80, 'spike', 0),
          O_FN(1650, 400, 20, 150, 'platform', 400)
      ],
      collectibles: [C_FN(1150, 100, 'gem', true)],
      enemies: [
          /* FIX: Re-centered enemy patrol to stay on platform */
          E_FN(412, 350 - 50, 20, 50, 180, 'sentry')
      ]
    },

    // Level 9: Lava, Mini-Platform, and Crow Dive (Minimal aerial threat)
    { playerX: 50, playerY: 0, goalX: EXTENDED_WIDTH - 50, goalY: 300, doorType: 'enemies',
        platforms: [
            P_FN(50, GAME_GROUND_Y - 32, 100, 32),
            /* [GEMINI FIX] Widened platforms from 50 to 80 */
            P_FN(200, 300, 80, 20),
            P_FN(400, 200, 80, 20),
            P_FN(600, 300, 80, 20),
            P_FN(800, 200, 80, 20),
            P_FN(1100, 300, 80, 20, true, 50, 1.5, 'y'),
            P_FN(1400, 150, 100, 20),
            P_FN(1700, 300, 200, 32)
        ],
        obstacles: [
            // [GEMINI FIX] Removed 'lava' to make this a true "sky" level per user request
            // O_FN(150, GAME_GROUND_Y, EXTENDED_WIDTH - 150, P_LOGICAL.GROUND_Y_OFFSET, 'lava'),
            O_FN(900, 0, 50, BASE_HEIGHT - 180, 'platform', 0),
            O_FN(900, GAME_GROUND_Y - 150, 50, 150, 'platform', GAME_GROUND_Y - 150)
        ],
        collectibles: [C_FN(1450, 100, 'sword')],
        enemies: [
            /* [GEMINI FIX] Made enemy static (range 0) to make level easier */
            E_FN(1160, 300 - 50, 20, 50, 0, 'sentry')
        ]
    },

    // Level 10: Size Change Puzzle & Precision Glide (Maximal platform safety)
    { playerX: 50, playerY: 0, goalX: 1800, goalY: 100, doorType: 'multi',
        platforms: [
            P_FN(50, GAME_GROUND_Y - 32, 100, 32),
            P_FN(150, 300, 250, 20), // Wider
            P_FN(500, 250, 150, 20), // Wider
            P_FN(800, 150, 80, 20), // Wider
            P_FN(1100, 250, 300, 20), // Wider
            P_FN(1500, 200, 80, 20), // Wider
            P_FN(1700, 150, 200, 32)
        ],
        obstacles: [
            O_FN(950, GAME_GROUND_Y - 150, 50, 150, 'platform', GAME_GROUND_Y - 150),
            O_FN(1500, 0, 50, BASE_HEIGHT - 120, 'spike', 0)
        ],
        collectibles: [C_FN(1200, 200, 'gem', true), C_FN(550, 300, 'sword')],
        enemies: [
            /* FIX: Re-centered enemy patrol to stay on platform */
            E_FN(1850, 150 - 50, 20, 50, 250, 'sentry')
        ]
    }
];

// ========================================================================
// SOUND ENGINE (REQ 9)
// ========================================================================

const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
let soundsLoaded = false;
const sounds = {};

// REQ 9: Basic oscillator sounds
function createSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!audioCtx) return () => {};

    return () => {
        if (isPaused) return;
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        oscillator.start();
        oscillator.stop(audioCtx.currentTime + duration);
    };
}

// REQ 9: Initialize audio only after first player action
function initAudio() {
    if (soundsLoaded) return;
    try {
        audioCtx = new AudioContext();
        // REQ 9: Low-volume sounds
        sounds.jump = createSound(440, 0.1, 'square', 0.1);
        sounds.collect = createSound(700, 0.05, 'triangle', 0.2);
        sounds.level_complete = createSound(500, 0.1, 'sine', 0.3);
        sounds.death_hit = createSound(100, 0.3, 'sawtooth', 0.3);
        sounds.powerup = createSound(1000, 0.1, 'square', 0.2);
        // REQ 2/9: Sound for sword attack
        sounds.sword_swing = createSound(300, 0.05, 'square', 0.1);
        soundsLoaded = true;
    } catch (e) {
        console.warn("AudioContext not supported or blocked.", e); // REQ 6: No console errors
        sounds.jump = sounds.collect = sounds.level_complete = sounds.death_hit = sounds.powerup = sounds.sword_swing = () => {};
        soundsLoaded = true;
    }
}

// Konami Code logic
/* [GEMINI FIX] Changed Konami code to L+1 per user request */
const konamiCode = ['KeyL', 'Digit1'];
let konamiIndex = 0;
function checkKonami(key) {
    if (key === konamiCode[konamiIndex]) {
        konamiIndex++;
        if (konamiIndex === konamiCode.length) {
            konamiIndex = 0;
            if (currentLevelIndex < levelData.length) {
                lives = 99;
                console.log("Konami Code Activated! Lives Set to 99.");
            }
            return true;
        }
    } else {
        konamiIndex = (key === konamiCode[0]) ? 1 : 0;
    }
    return false;
}

// REQ 1: Removed fitCanvasCssSize function and resize listener

// ========================================================================
// PERSISTENCE & LEVEL LOADING (REQ 8)
// ========================================================================

function localSave() {
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => {
        if (!player) return;

        const state = {
            score: gameScore,
            lives: lives,
            inventory: player.inventory,
            playerSize: player.height / player.baseHeight
        };
         try {
               localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
         } catch (e) { console.warn("Save failed.", e); }
    }, 150);
}

function loadSave() {
    let defaultState = {
        currentLevel: 0,
        score: 0,
        lives: 10,
        // FIX: Give player swords by default to fix "sword not activating"
        inventory: { swords: 99, rings: 0, gems: 0 },
        playerSize: 1.0
    };

    try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
            const data = JSON.parse(saved);
            
            if (typeof data.score === 'number') gameScore = data.score;
            if (typeof data.lives === 'number' && data.lives > 0) lives = data.lives;
            else lives = defaultState.lives;
            
            data.inventory = data.inventory || defaultState.inventory;
            data.playerSize = data.playerSize || 1.0;
            data.currentLevel = 0; // Always start at level 1 (index 0)
            
            return data;
        }
    } catch (e) {
        console.warn("Save invalid. Starting fresh.", e);
        localStorage.removeItem(STORAGE_KEY);
    }
    return defaultState;
}

let gameScore = 0;
let currentLevelIndex = 0;
let lives = 10;
let goalDoor = { x: 0, y: 0, w: 40, h: 70, open: true, type: 'gem' };
let isGameOver = false;

// REQ 8: Load level data
function loadLevel(levelIndex) {
    if (levelIndex >= levelData.length) {
        currentLevelIndex = levelData.length;
        isPaused = true; // FIX: Pause game on win
        return;
    } else {
        currentLevelIndex = levelIndex;
    }
    
    const level = levelData[currentLevelIndex];

    obstacles = [];
    collectibles = [];
    platforms = [];
    particles = [];
    enemies = [];

    const startX = level.playerX;
    const currentHeight = player ? player.height : PLAYER_H_BASE;
    const currentWidth = player ? player.width : PLAYER_H_BASE * 0.8 / 1.5;

    let initialPlatformY = level.playerY;

    // REQ 8: Load all platform types
    const allPlatforms = (level.platforms || [])
        .concat(level.movingPlatforms || [])
        .concat(level.platforms2 || []);

    const startPlatform = allPlatforms.find(p => p.x <= startX && p.x + p.w >= startX);
    
    // Check if ground exists (e.g. lava or just a solid floor)
    // [GEMINI FIX] Simplified logic. Ground exists if (lava) OR (it's Level 2 or 5).
    const groundExists = (level.obstacles || []).some(o => o.type === 'lava') || 
                         currentLevelIndex === 1 || 
                         currentLevelIndex === 4;


     if (startPlatform) {
        initialPlatformY = startPlatform.y - currentHeight;
    } else {
        // Fallback: If no platform, place on ground (or at y=0 if ground doesn't exist)
        if (groundExists) {
             initialPlatformY = GAME_GROUND_Y - currentHeight;
        } else {
             initialPlatformY = 400 - currentHeight; // e.g. Level 3 start
        }
     }
    
     if(player) {
        player.resetPosition(startX, initialPlatformY, currentWidth, currentHeight);
     }

     allPlatforms.forEach(p => platforms.push(new Platform(p.x, p.y, p.w, p.h, p.moving, p.range, p.speed, p.axis)));

     (level.obstacles || []).forEach(o => {
        obstacles.push(new Obstacle(o.x, o.y, o.w, o.h, o.type));
     });
    
     (level.collectibles || []).forEach(c => collectibles.push(new Collectible(c.x, c.y, c.type, c.powerup)));
     (level.enemies || []).forEach(e => enemies.push(new Enemy(e.x, e.y, e.w, e.h, e.range, e.type)));


     goalDoor.x = level.goalX;
     goalDoor.y = level.goalY - 70;
     goalDoor.w = 40;
     goalDoor.h = 70;
     goalDoor.type = level.doorType;
     goalDoor.open = checkDoorCondition();
    
     fadeAlpha = 1.0; // Start fade in on new level load

     if(player) {
        player.vy = 0;
        player.applyForces();
        player.integrate();
        player.solveConstraints();
     }
}

// REQ 6: Door logic
function checkDoorCondition() {
     const level = levelData[currentLevelIndex];
     if (!player || !level) return false;

     switch (level.doorType) {
        case 'gem':
            return player.inventory.gems > 0;
        case 'enemies':
            return enemies.length === 0;
        case 'multi':
            return player.inventory.gems > 0 && enemies.length === 0;
        default:
            return true;
     }
}

// ========================================================================
// CORE UTILITIES (AABB Collision)
// ========================================================================
function aabbCollision(rect1, rect2) {
     const w1 = rect1.w || rect1.width;
     const h1 = rect1.h || rect1.height;
     const w2 = rect2.w || rect2.width;
     const h2 = rect2.h || rect2.height;

     return rect1.x < rect2.x + w2 &&
            rect1.x + w1 > rect2.x &&
            rect1.y < rect2.y + h2 &&
            rect1.y + h1 > rect2.y;
}

class Particle {
     constructor(x, y, vx, vy, color, life, size = 4) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color; // Will be ignored by draw, but kept for structure
        this.life = life;
        this.maxLife = life;
        this.size = size;
     }

     update(dt) {
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.vy += 0.1 * dt * 60;
        this.vx *= 0.98;
        this.life -= dt;
        return this.life > 0;
     }

     draw(ctx) {
        const alpha = Math.max(0, this.life / this.maxLife);
        ctx.globalAlpha = alpha;
        
        // REQ 7: All particles are black
        ctx.fillStyle = '#000000';
        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
        ctx.globalAlpha = 1.0;
     }
}

function spawnParticles(x, y, count, color, size = 4) {
     for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 1;
        particles.push(new Particle(
            x, y,
            Math.cos(angle) * speed,
            Math.sin(angle) * speed - 2,
            '#000000', // REQ 7: Color is always black
            0.5 + Math.random() * 0.5,
            size
        ));
     }
}

class Obstacle {
     constructor(x, y, w, h, type = 'spike') {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.type = type;
        this.animOffset = Math.random() * 100;
        
        this.width = this.w;
        this.height = this.h;
     }

     checkCollision(rect) {
        return aabbCollision(rect, this);
     }

     draw(ctx) {
        // REQ 7: All obstacles are black
        ctx.fillStyle = '#000000';
        // REQ 7: Remove all shadows
        ctx.shadowBlur = 0;

        if (this.type === 'spike') {
            const spikeDrawY = this.y + this.h;
            const spikeHeight = 20;
            
            const spikeCount = Math.floor(this.w / 15);
            for (let i = 0; i < spikeCount; i++) {
                const sx = this.x + i * 15 + 7.5;
                ctx.beginPath();
                ctx.moveTo(sx - 5, spikeDrawY);
                ctx.lineTo(sx, spikeDrawY - spikeHeight);
                ctx.lineTo(sx + 5, spikeDrawY);
                ctx.closePath();
                ctx.fill();
            }
        } else if (this.type === 'lava') {
            // [GEMINI FIX] User request: Add textured lava, rocks, and bubbles.
            // This assumes black ground is drawn *underneath* by the main draw loop.
            
            // We draw the lava slightly higher and shorter to let the black ground show.
            const lavaY = this.y + 5; 
            const lavaH = this.h - 5;
            const anim = (Date.now() + this.animOffset) / 1000; // Animation timer

            // 1. Main Lava color (Red)
            ctx.fillStyle = '#FF0000'; // Red
            ctx.fillRect(this.x, lavaY, this.w, lavaH);

            // 2. Top "hot" layer (Orange, wavy)
            ctx.fillStyle = '#FFA500'; // Orange
            ctx.beginPath();
            ctx.moveTo(this.x, lavaY + 5); // Start 5px down
            for (let i = 0; i <= this.w; i += 10) {
                const waveY = lavaY + Math.sin(i * 0.1 + anim * 2) * 3;
                ctx.lineTo(this.x + i, waveY);
            }
            ctx.lineTo(this.x + this.w, lavaY); // Go to top-right corner
            ctx.lineTo(this.x, lavaY); // Go to top-left corner
            ctx.closePath();
            ctx.fill();

            // 3. Rocks and Bubbles
            const rockCount = Math.floor(this.w / 150);
            const bubbleCount = Math.floor(this.w / 50);
            
            // Rocks
            ctx.fillStyle = '#333333'; // Dark grey rocks
            for (let i = 0; i < rockCount; i++) {
                const rockX = this.x + (i * 150 + this.animOffset * 20) % this.w;
                const rockY = lavaY + 20 + Math.sin(anim + i) * 10;
                if (rockY > lavaY + 5) { // Don't draw over the top layer
                    ctx.fillRect(rockX, rockY, 15, 8);
                }
            }
            
            // Bubbles
            ctx.fillStyle = '#8B0000'; // Dark red bubbles
            for (let i = 0; i < bubbleCount; i++) {
                const bubbleX = this.x + (i * 50 + this.animOffset * 10) % this.w;
                const bubbleY = lavaY + (lavaH / 2) + Math.sin(anim * 2 + i) * (lavaH / 2 - 5);
                ctx.beginPath();
                ctx.arc(bubbleX, bubbleY, 3, 0, Math.PI * 2);
                ctx.fill();
            }

        } else if (this.type === 'platform') {
            ctx.fillRect(this.x, this.y, this.w, this.h);
        }
     }
}

class Enemy {
     constructor(x, y, w, h, range, type = 'sentry') {
        this.x = x;
        this.y = y;
        this.startY = y;
        this.w = w;
        this.h = h;
        this.type = type;
        this.startX = x;
        this.range = range;
        this.moveDir = 1;
        this.moveSpeed = 1.0;
        this.isDead = false;

        this.width = this.w;
        this.height = this.h;
     }

     update(dt) {
        if (this.isDead || this.range === 0) return; // FIX: Don't move if range is 0

        // REQ 3: Enemy movement
        // FIX: Kept original centered patrol logic, but smoothed the reversal
        const moveStep = this.moveSpeed * this.moveDir * dt * 60;
        this.x += moveStep;

        const rightBoundary = this.startX + (this.range / 2);
        const leftBoundary = this.startX - (this.range / 2);

        if (this.moveDir > 0 && this.x > rightBoundary) {
            this.moveDir = -1;
            this.x = rightBoundary; // Snap to boundary
        } else if (this.moveDir < 0 && this.x < leftBoundary) {
            this.moveDir = 1;
            this.x = leftBoundary; // Snap to boundary
        }
     }

     checkCollision(rect) {
         if (this.isDead) return false;
         // REQ 3: Enemy collision
         const hitbox = {x: this.x - 5, y: this.y - 5, w: this.w + 10, h: this.h + 10};
         return aabbCollision(rect, hitbox);
     }

     draw(ctx) {
         if (this.isDead) return;

         const p = { x: this.x + this.w / 2, y: this.y + this.h };
         const h = this.h;
        
         const headY = p.y - h + 5;
         const bodyTop = p.y - h + 10;
         const bodyBottom = p.y - 5;
         const armY = p.y - h + 15;
         const legBottom = p.y;
        
         // REQ 3/7: Simple black silhouette, no colors, no shadows
         ctx.fillStyle = '#000000';
         ctx.strokeStyle = '#000000'; // Make stroke black
         ctx.lineWidth = 2; // Thinner lines for silhouette
         ctx.shadowBlur = 0;

         // Head
         ctx.beginPath();
         ctx.arc(p.x, headY, 5, 0, Math.PI * 2);
         ctx.fill();
         // Body
         ctx.fillRect(p.x - 2, bodyTop, 4, bodyBottom - bodyTop);
         // Legs
         ctx.beginPath();
         ctx.moveTo(p.x, bodyBottom); ctx.lineTo(p.x - 4, legBottom);
         ctx.moveTo(p.x, bodyBottom); ctx.lineTo(p.x + 4, legBottom);
         ctx.stroke();
         // Arms
         ctx.beginPath();
         ctx.moveTo(p.x, armY); ctx.lineTo(p.x - 6, armY + 5);
         ctx.moveTo(p.x, armY); ctx.lineTo(p.x + 6, armY + 5);
         ctx.stroke();
     }
}

class Platform {
     constructor(x, y, w, h, moving = false, range = 100, speed = 1, axis = 'x') {
         this.x = x;
         this.y = y;
         this.startX = x;
         this.startY = y;
         this.w = w;
         this.h = h;
         this.moving = moving;
         this.moveSpeed = speed;
         this.moveRange = range;
         this.axis = axis;
         this.moveDir = 1;
         this.prevX = x;
         this.prevY = y;

         this.width = this.w;
         this.height = this.h;
     }

     update(dt) {
         this.prevX = this.x;
         this.prevY = this.y;

         if (this.moving) {
             // REQ 4: Platform physics
             const moveStep = this.moveSpeed * this.moveDir * dt * 60;
             
             if (this.axis === 'x') {
                 this.x += moveStep;
                 /* FIX: Replaced jerky "snap" logic with smooth reversal */
                 if (this.moveDir > 0 && this.x > this.startX + this.moveRange) {
                     this.moveDir = -1;
                     this.x = this.startX + this.moveRange; // Snap to boundary
                 } else if (this.moveDir < 0 && this.x < this.startX) {
                     this.moveDir = 1;
                     this.x = this.startX; // Snap to boundary
                 }
             } else { // 'y' axis
                 this.y += moveStep;
                 /* FIX: Replaced jerky "snap" logic with smooth reversal */
                 if (this.moveDir > 0 && this.y > this.startY + this.moveRange) {
                     this.moveDir = -1;
                     this.y = this.startY + this.moveRange; // Snap to boundary
                 } else if (this.moveDir < 0 && this.y < this.startY) {
                     this.moveDir = 1;
                     this.y = this.startY; // Snap to boundary
                 }
             }
         }
     }

     checkCollision(rect) {
         return aabbCollision(rect, this);
     }

     draw(ctx) {
         // REQ 7: Platforms are black
         ctx.fillStyle = '#000000';
         ctx.fillRect(this.x, this.y, this.w, this.h);
     }
}

class Collectible {
     constructor(x, y, type, powerup = false) {
         this.x = x;
         this.y = y;
         this.type = type;
         this.collected = false;
         this.bobOffset = Math.random() * Math.PI * 2;
         this.value = type === 'ring' ? 1 : type === 'sword' ? 1 : 5;
         this.scoreValue = type === 'ring' ? 10 : type === 'sword' ? 100 : 500;
         this.rotation = 0;
         this.isPowerUp = powerup;

         this.width = 20;
         this.height = 20;

         if (this.isPowerUp && this.type === 'gem') {
             this.powerUpType = 'superjump';
         } else {
             this.powerUpType = null;
         }
     }

     update(dt) {
         this.bobOffset += dt * 3;
         this.rotation += dt * 2;
     }

     checkCollision(rect) {
         if (this.collected) return false;
         const hitbox = {x: this.x - 10, y: this.y - 10, w: 20, h: 20};
         return aabbCollision(rect, hitbox);
     }

     draw(ctx) {
         if (this.collected) return;

         const bobY = this.y + Math.sin(this.bobOffset) * 5;

         ctx.save();
         ctx.translate(this.x, bobY);

         // REQ 7: No shadows or glows
         ctx.shadowBlur = 0;
        
         // REQ 7: All collectibles are black
         ctx.fillStyle = '#000000';
         ctx.strokeStyle = '#000000';

         if (this.type === 'ring') {
             ctx.rotate(this.rotation);
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.arc(0, 0, 8, 0, Math.PI * 2);
             ctx.stroke();
         } else if (this.type === 'sword') {
             ctx.fillRect(-3, -12, 6, 20);
             ctx.fillRect(-4, 6, 8, 6);
             ctx.beginPath();
             ctx.moveTo(0, -14);
             ctx.lineTo(-6, -10);
             ctx.lineTo(6, -10);
             ctx.closePath();
             ctx.fill();
         } else if (this.type === 'gem') {
             ctx.rotate(this.rotation);
             ctx.beginPath();
             ctx.moveTo(0, -10);
             ctx.lineTo(6, -3);
             ctx.lineTo(4, 8);
             ctx.lineTo(-4, 8);
             ctx.lineTo(-6, -3);
             ctx.closePath();
             ctx.fill();
         }

         ctx.restore();
     }
}

class StretchyKing {
     constructor(saveData) {
         this.inventory = saveData.inventory;
         this.vx = 0;
         this.vy = 0;
         this.isGrounded = false;
         // REQ 2/6: Double jump fix
         this.jumpsLeft = 2;
         this.isGliding = false;

         this.superJumpTimer = 0;
         this.attackTimer = 0;

         this.animTimer = 0;
         this.direction = 'right';

         this.x = saveData.x;
         this.y = saveData.y;
         this.baseWidth = TILE_SIZE * 0.8;
         this.baseHeight = PLAYER_H_BASE;
         this.width = this.baseWidth * saveData.playerSize;
         this.height = this.baseHeight * saveData.playerSize;
         this.platform = null;
         this.lastGroundedY = saveData.y;

         this.camera = { x: this.x + this.width/2, y: this.y + this.height/2 };
     }

     resetPosition(startX, startY, width, height) {
         this.x = startX;
         this.y = startY;
         this.vy = 0;
         // REQ 2: Reset jumps on respawn
         this.jumpsLeft = 2;
         this.isGrounded = false;
        
         this.vx = 0;
         this.isGliding = false;
         this.superJumpTimer = 0;
         this.attackTimer = 0;
        
         this.width = width;
         this.height = height;
        
         // Snap camera to start
         this.camera.x = startX + width / 2;
         this.camera.y = startY + height / 2;
         cameraInitialised = true;
     }

     applyInput(dt) {
         const currentJumpInput = input.jump;
         input.jumpPressed = (currentJumpInput && !input._jumpLastFrame);
         input._jumpLastFrame = currentJumpInput;

         const currentUpInput = input.up;
        
         // 1. Horizontal Movement (REQ 2, 5)
         if (input.left) {
             this.vx = -P_LOGICAL.VX_MAX;
             this.direction = 'left';
         } else if (input.right) {
             this.vx = P_LOGICAL.VX_MAX;
             this.direction = 'right';
         } else {
             this.vx = 0;
         }

         // 2. Stretching/Shrinking (REQ 2, 5)
         let oldHeight = this.height;
         let sizeChanged = false;
         const baseH = this.baseHeight;
        
         const maxH = baseH * P_LOGICAL.L_MAX_FACTOR;
         const minH = baseH * P_LOGICAL.L_MIN_FACTOR;

         // Maximize Toggle (B)
         if (input.sizeChangeUp) {
             if (Math.abs(this.height - maxH) < 0.1) { // Check if already maxed
                 this.height = baseH;
                 this.width = this.baseWidth;
             } else {
                 this.height = maxH;
                 this.width = this.baseWidth * P_LOGICAL.L_MAX_FACTOR;
             }
             sizeChanged = true;
             input.sizeChangeUp = false;
         }
        
         // Minimize Toggle (V)
         if (input.sizeChangeDown) {
             if (Math.abs(this.height - minH) < 0.1) { // Check if already min
                 this.height = baseH;
                 this.width = this.baseWidth;
             } else {
                 this.height = minH;
                 this.width = this.baseWidth * P_LOGICAL.L_MIN_FACTOR;
             }
             sizeChanged = true;
             input.sizeChangeDown = false;
         }
        
         // REQ 6: Prevent clipping on size change
         if (sizeChanged && this.isGrounded) {
             this.y += (oldHeight - this.height);
         } else if (sizeChanged && this.height > oldHeight) {
             this.vy = -1;
         }


         // 3. Jump (Space/W/ArrowUp) (REQ 2, 5, 6)
         if (input.jumpPressed && this.jumpsLeft > 0) {
             this.vy = P_LOGICAL.JUMP_IMPULSE_BASE * (this.height / this.baseHeight);
             this.isGrounded = false;
             this.jumpsLeft--; // Consume a jump
             sounds.jump();
             spawnParticles(this.x + this.width / 2, this.y + this.height, 10, '#000000', 5);
         }

         // 4. Glide (Down/S) (REQ 2, 5)
         // Glide only when Down is pressed, in air, and falling
         this.isGliding = input.down && !this.isGrounded && this.vy > 0;
        
         // Super Jump (Fly) Logic (from old code, unused but safe)
         if (this.superJumpTimer > 0) {
             this.superJumpTimer--;
             if (currentUpInput) {
                 // This logic is for an old powerup, not the standard glide
                 this.vy = Math.min(this.vy, -P_LOGICAL.VX_MAX * 0.5);
             }
         }

         // 5. Sword Action (X/E) (REQ 2, 5)
         if (input.action && this.inventory.swords > 0 && this.attackTimer === 0) {
             this.attackTimer = P_LOGICAL.SWORD_DUR;
             sounds.sword_swing();
         }
         if (this.attackTimer > 0) {
             this.attackTimer--;
         }

         // 6. Collectibles
         this.handleCollectibles();

         // 7. Timer Updates
         this.animTimer = (this.animTimer + 1) % 60;
     }


     handleCollectibles() {
         collectibles = collectibles.filter(col => {
             const playerRect = { x: this.x, y: this.y, w: this.width, h: this.height };
             if (col.checkCollision(playerRect)) {
                 col.collected = true;
                 gameScore += col.scoreValue;
                 sounds.collect();

                 if (col.type === 'ring') player.inventory.rings += col.value;
                 if (col.type ==='sword') player.inventory.swords += col.value;
                 if (col.type === 'gem') player.inventory.gems += col.value;

                 if (col.isPowerUp) {
                     sounds.powerup();
                     if (col.powerUpType === 'superjump') this.superJumpTimer = P_LOGICAL.FLY_DUR;
                 }
                
                 return false;
             }
             return true;
         });
     }


     // AABB Physics Integration
     applyForces() {
         let gravity = P_LOGICAL.G_ACCEL;

         // SuperJump powerup logic
         if (this.superJumpTimer > 0) {
             if (input.up) {
                 this.vy = Math.min(this.vy, -P_LOGICAL.VX_MAX * 0.5);
                 gravity = 0;
             } else {
                 gravity *= 0.5;
             }
         }

         // REQ 2: Glide physics
         if (this.isGliding) {
             this.vy = Math.min(this.vy, P_LOGICAL.SLOW_FALL_SPEED);
             gravity = 0;
         }
        
         // REQ 4: Gravity
         this.vy = Math.min(this.vy + gravity, P_LOGICAL.SLOW_FALL_SPEED + 10);
     }

     integrate() {
         // Apply horizontal velocity
         // FIX: Moved from solveConstraints to integrate
         this.x += this.vx;
         // Apply vertical velocity
         this.y += this.vy;
     }

     solveConstraints() {
         // FIX: Calculate positions *before* solving
         const newY = this.y;
         const oldY = this.y - this.vy; // Get y from *before* integrate
         const newX = this.x;
         const oldX = this.x - this.vx; // Get x from *before* integrate

         let wasGrounded = this.isGrounded;
         this.isGrounded = false;
         this.platform = null;

         const playerRect = { x: newX, y: newY, w: this.width, h: this.height };
         const solidObjects = platforms.concat(obstacles.filter(o => o.type === 'platform'));

         // REQ 4: Accurate Collisions
         // --- 1. Horizontal Collision (X-axis) ---
         solidObjects.forEach(p => {
             // Check horizontal collision using *old* Y position
             const futureRectX = { x: newX, y: oldY, w: this.width, h: this.height };
            
             if (aabbCollision(futureRectX, p)) {
                 if (this.vx > 0) { // Moving right
                     this.x = p.x - this.width; // Snap to left edge
                 } else if (this.vx < 0) { // Moving left
                     this.x = p.x + p.width; // Snap to right edge
                 }
                 this.vx = 0; // Stop horizontal velocity
                 playerRect.x = this.x; // Update rect x for vertical check
             }
         });

         // --- 2. Vertical Collision (Y-axis) ---
         let collidedPlatform = null;
         const pastRectY = { x: playerRect.x, y: oldY, w: this.width, h: this.height };
         // FIX: Increased snap tolerance to catch high-speed (double jump) falls
         const snapTolerance = 8;

         solidObjects.forEach(p => {
             if (aabbCollision(playerRect, p)) {
                
                 // Landing on top (falling down)
                 // Check that the *bottom* of the player *was* above the *top* of the platform
                 if (this.vy >= 0 && pastRectY.y + pastRectY.h <= p.y + snapTolerance) {
                     this.y = p.y - this.height;
                     this.vy = 0;
                     this.isGrounded = true;
                     collidedPlatform = p;
                 }
                 // Hitting head on bottom (jumping up)
                 // Check that the *top* of the player *was* below the *bottom* of the platform
                 else if (this.vy < 0 && pastRectY.y >= p.y + p.height - snapTolerance) {
                     this.y = p.y + p.height;
                     this.vy = 0;
                 }
             }
         });

         // Apply platform movement stickiness
         if (this.isGrounded && collidedPlatform && collidedPlatform.moving) {
             const plat = collidedPlatform;
             const dx = plat.x - plat.prevX;
             const dy = plat.y - plat.prevY; // [GEMINI FIX] Add Y-axis stickiness
             this.x += dx;
             this.y += dy; // [GEMINI FIX] Apply Y-axis stickiness
         }
        
         // Check if ground exists on this level
        // [GEMINI FIX] Simplified logic. Ground exists if (lava) OR (it's Level 2 or 5).
        const groundExists = (obstacles || []).some(o => o.type === 'lava') || 
                             currentLevelIndex === 1 || 
                             currentLevelIndex === 4;
        // [GEMINI FIX] Check for lava to prevent ground snap
        const lavaExists = (obstacles || []).some(o => o.type === 'lava');

         // Ground detection
         if (this.y >= GAME_GROUND_Y - this.height && groundExists && !lavaExists) { // [GEMINI FIX] Don't snap to ground on lava levels
             this.isGrounded = true;
             this.y = Math.min(this.y, GAME_GROUND_Y - this.height);
             this.vy = 0;
         }

         // REQ 2: Jump reset
         if (this.isGrounded && !wasGrounded) {
             this.jumpsLeft = 2;
         }
     }

     updateCamera(dt) {
         if (!cameraInitialised) return;

         let cx = this.camera.x, cy = this.camera.y;
         const targetX = this.x + this.width / 2;
         const targetY = this.y + this.height / 2;

         const followSpeed = cameraCfg.follow * 60 * dt;

         // Smooth camera interpolation
         cx += (targetX - cx) * followSpeed;
         cy += (targetY - cy) * followSpeed;
        
         // Clamp X position to level bounds
         const levelMaxX = EXTENDED_WIDTH;
         const halfBaseWidth = BASE_WIDTH / 2;
         if (levelMaxX > BASE_WIDTH) {
             cx = Math.max(halfBaseWidth, Math.min(cx, levelMaxX - halfBaseWidth));
         } else {
             cx = halfBaseWidth;
         }
        
         // Clamp Y position to prevent showing below ground or too high
         // REQ 6 (Checklist): Static centered viewport (Y axis)
         const minCamY = BASE_HEIGHT / 2;
         cy = Math.max(minCamY, Math.min(cy, minCamY));

         this.camera.x = cx;
         this.camera.y = cy;
     }

     draw(ctx) {
         ctx.save();
         const p = { x: this.x + this.width / 2, y: this.y + this.height };
         const scale = this.height / this.baseHeight;

         const headY = p.y - this.height + (7 * scale);
         const bodyTop = p.y - this.height + (14 * scale);
         const bodyBottom = p.y - this.height + (30 * scale);
         const armY = p.y - this.height + (22 * scale);
         const legBottom = p.y - (4 * scale);

         let animState = 'idle';
         if (!this.isGrounded) animState = 'jumping';
         else if (Math.abs(this.vx) > 0.1) animState = 'walking';

         // --- 1. Draw Effects (REQ 7: No glows) ---
         ctx.shadowBlur = 0;

         // --- 2. Draw King (REQ 2/7: Black, no cape) ---
         ctx.strokeStyle = '#000000';
         ctx.lineWidth = 3 * scale;
         ctx.fillStyle = '#000000';

         // REQ 2: No cape
         
         // Body & Limbs (Black)
         ctx.beginPath();
         ctx.moveTo(p.x, bodyTop);
         ctx.lineTo(p.x, bodyBottom);
         ctx.stroke(); // Body

         // Legs (Animated)
         ctx.beginPath();
         let legOffset = animState === 'walking' ? Math.sin(this.animTimer * 0.25) * 10 * scale : 5 * scale;
         ctx.moveTo(p.x, bodyBottom);
         ctx.lineTo(p.x - legOffset, legBottom);
         ctx.moveTo(p.x, bodyBottom);
         ctx.lineTo(p.x + legOffset, legBottom);
         ctx.stroke();

        // [GEMINI FIX] Re-wrote Arm & Sword logic to fix ReferenceError and draw the sword.
        // Arms (Animated)
        const dir = this.direction === 'right' ? 1 : -1;
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3 * scale;
        
        let armOffset = animState === 'walking' ? Math.sin(this.animTimer * 0.25) * 6 * scale : 0;

        if (this.attackTimer > 0) {
            // Attacking arm
            const armX = p.x + (15 * dir * scale);
            const armY_down = armY + 5 * scale;
            
            ctx.beginPath();
            ctx.moveTo(p.x, armY);
            ctx.lineTo(armX, armY_down);
            ctx.stroke();
            
            // Draw simple black sword
            const swordY = armY_down;
            const swordX1 = p.x + (10 * dir * scale);
            const swordX2 = p.x + (30 * dir * scale); // 20-pixel-long sword
            const swordHilt = 5 * scale;
            
            ctx.fillStyle = '#000000';
            ctx.lineWidth = 3 * scale;
            
            // Blade
            ctx.beginPath();
            ctx.moveTo(swordX1, swordY);
            ctx.lineTo(swordX2, swordY);
            ctx.stroke();
            
            // Hilt
            ctx.beginPath();
            ctx.moveTo(swordX1, swordY - swordHilt);
            ctx.lineTo(swordX1, swordY + swordHilt);
            ctx.stroke();

            // Other arm (idle)
            ctx.beginPath();
            ctx.moveTo(p.x, armY);
            ctx.lineTo(p.x - (dir * (5 * scale)), armY + 10 * scale);
            ctx.stroke();

        } else {
            // Idle/Walking Arms
            ctx.beginPath();
            // Arm 1
            ctx.moveTo(p.x, armY);
            ctx.lineTo(p.x - (5 * scale) - armOffset, armY + 10 * scale);
            // Arm 2
            ctx.moveTo(p.x, armY);
            ctx.lineTo(p.x + (5 * scale) + armOffset, armY + 10 * scale);
            ctx.stroke();
        }
        // [GEMINI FIX] End of fixed arm logic
         
         // Head
         ctx.fillStyle = '#000000';
         ctx.beginPath();
         ctx.arc(p.x, headY, 7 * scale, 0, Math.PI * 2);
         ctx.fill();
         ctx.strokeStyle = '#000000';
         ctx.lineWidth = 2 * scale;
         ctx.stroke();

         // REQ 2: Crown (Simple black shape)
         ctx.fillStyle = '#000000';
         ctx.strokeStyle = '#000000';
         ctx.lineWidth = 1 * scale;
         ctx.beginPath();
         ctx.moveTo(p.x - 6 * scale, headY - 4 * scale);
         ctx.lineTo(p.x - 3 * scale, headY - 10 * scale);
         ctx.lineTo(p.x, headY - 7 * scale);
         ctx.lineTo(p.x + 3 * scale, headY - 10 * scale);
         ctx.lineTo(p.x + 6 * scale, headY - 4 * scale);
         ctx.closePath();
         ctx.fill();
         ctx.stroke();
         
         ctx.restore();
     }
}

function drawDoor(ctx) {
     const { x, y, w, h } = goalDoor;

     // REQ 7: Black
     ctx.fillStyle = '#000000';
     ctx.fillRect(x - 5, y - 5, w + 10, h + 10);

     const isReady = checkDoorCondition();
     // Draw inner rect slightly smaller to show frame
     ctx.fillStyle = '#FFFFFF'; // White inner door
     ctx.fillRect(x, y, w, h);

     // Draw handle
     ctx.fillStyle = '#000000';
     ctx.beginPath();
     ctx.arc(x + w * 0.8, y + h / 2, 3, 0, Math.PI * 2);
     ctx.fill();

     /* FIX: Changed font to Georgia */
     ctx.font = '14px Georgia';
     ctx.textAlign = 'center';

     let hint = 'GOAL';
     let doorStatus = levelData[currentLevelIndex].doorType;

     if (doorStatus === 'gem') hint = `Collect Gem`;
     else if (doorStatus === 'enemies') hint = `Defeat Enemies (${enemies.length})`;
     else if (doorStatus === 'multi') hint = `Gem + Defeat Enemies`;

     // REQ 7: Black text
     /* FIX: Changed text color to light gray for visibility */
     ctx.fillStyle = '#AAAAAA';
     if (isReady) {
         hint = 'GOAL (ENTER)';
     }

     /* [GEMINI FIX] Moved text from (y + h + 15) to (y - 10) to prevent cutoff */
     ctx.fillText(hint, x + w / 2, y - 10);
}

function checkGoalCollision() {
     const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
     if (aabbCollision(playerRect, goalDoor) && checkDoorCondition()) {
         sounds.level_complete();
         levelAdvance();
     }
}

function levelAdvance() {
     localSave();

     const currentInventory = { ...player.inventory };
     const currentSizeFactor = player.height / player.baseHeight;

     if (currentLevelIndex < levelData.length - 1) {
         loadLevel(currentLevelIndex + 1);
         player.height = player.baseHeight * currentSizeFactor;
         player.width = player.baseWidth * currentSizeFactor;
         player.superJumpTimer = 0;
     } else {
         isPaused = true; // Set to indicate completion
         currentLevelIndex = levelData.length;
     }

     player.inventory = currentInventory;
}

function handlePlayerDeath() {
     if (respawnPending) return;
     respawnPending = true;

     lives--;

     sounds.death_hit();
     spawnParticles(player.x + player.width/2, player.y + player.height/2, 50, '#000000', 10);

     // FIX: Trigger Game Over when lives hit 0
     if (lives <= 0) {
         isGameOver = true;
         isPaused = true;
         respawnPending = false;
     } else {
         const currentInventory = { ...player.inventory };
         const currentSizeFactor = player.height / player.baseHeight;
         const currentLevel = currentLevelIndex;
         
         loadLevel(currentLevel); // Respawn at current level
         
         player.inventory = currentInventory;
         player.height = player.baseHeight * currentSizeFactor;
         player.width = player.baseWidth * currentSizeFactor;
         player.superJumpTimer = 0; // Reset powerup on death

         respawnPending = false;
     }
     localSave();
}


// ========================================================================
// GAME LOOP & INITIALIZATION
// ========================================================================

function update(dt) {
     if (isPaused || respawnPending) {
         particles = particles.filter(p => p.update(dt));
         return;
     }

     accumulator += dt;
     while (accumulator >= PHYSICS_STEP) {
         const fixedDT = PHYSICS_STEP;

         platforms.forEach(plat => plat.update(fixedDT));
         enemies.forEach(e => e.update(fixedDT));
         collectibles.forEach(col => col.update(fixedDT));
         particles = particles.filter(p => p.update(fixedDT));

         player.applyInput(fixedDT);
         player.applyForces();
         
         let hitHazard = false;
         
         player.integrate();
         
         player.solveConstraints();
         
         // REQ 6: Check for hazards *after* constraints are solved
         const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };
         obstacles.forEach(obs => {
             if (obs.type !== 'platform' && obs.checkCollision(playerRect)) {
                 hitHazard = true;
             }
         });

         player.updateCamera(fixedDT);

         checkGoalCollision();

         enemies = enemies.filter(e => {
             if (!e.isDead) {
                 const enemyRect = {x: e.x, y: e.y, w: e.w, h: e.h};

                 // Sword Hitbox Check
                 if (player.attackTimer > 0) {
                    
                    // [GEMINI FIX] Corrected sword hitbox logic to match new draw code.
                    const p = { x: player.x + player.width / 2, y: player.y + player.height };
                    const scale = player.height / player.baseHeight;
                    const dir = player.direction === 'right' ? 1 : -1;
                    const armY = p.y - player.height + (22 * scale);
                    const swordY = armY + 5 * scale; // Matches draw logic
                    const swordLength = 20 * scale; // Matches draw logic (30-10)
                    
                    const swordHitbox = {
                        x: (dir > 0) ? p.x + (10 * scale) : p.x - (30 * scale),
                        y: swordY - (5 * scale), // A small vertical buffer
                        w: swordLength,
                        h: 10 * scale
                    };
                    // [GEMINI FIX] End of corrected hitbox logic.

                    // REQ 3: Enemy death
                    if (aabbCollision(swordHitbox, enemyRect)) {
                        spawnParticles(e.x + e.w/2, e.y + e.h/2, 20, '#000000', 8);
                        sounds.collect(); // Use collect sound for kill
                        gameScore += 200;
                        return false; // Remove enemy
                    }
                 }

                 // Player-Enemy Collision (REQ 3)
                 if (e.checkCollision(playerRect)) {
                     hitHazard = true;
                     return true;
                 }
             }
             return true;
         });

         // REQ 6: Death
         // Check for death pit (levels with no ground)
        // [GEMINI FIX] Simplified logic. Ground exists if (lava) OR (it's Level 2 or 5).
        const groundExists = (obstacles || []).some(o => o.type === 'lava') || 
                                 currentLevelIndex === 1 || 
                                 currentLevelIndex === 4;
         
         if (hitHazard || (!groundExists && player.y > BASE_HEIGHT + 50)) {
             handlePlayerDeath();
         }
         
         if (fadeAlpha > 0) {
             fadeAlpha = Math.max(0, fadeAlpha - fixedDT * 2);
         }

         localSave();
         accumulator -= PHYSICS_STEP;
     }
}

function draw() {
     // FIX: Clear the *entire physical* canvas first to prevent ghosting
     ctx.clearRect(0, 0, canvas.width, canvas.height); 

     // REQ 1: Use DPR for sharp rendering
     ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
     // REQ 1/7: White background
     ctx.fillStyle = '#FFFFFF';
     ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT); // Clear logical canvas

     if (player && player.camera) {
         ctx.save();
         
         const camXLogical = player.camera.x;
         const camYLogical = player.camera.y;

         // Apply camera translation
         ctx.translate(BASE_WIDTH/2 - camXLogical, BASE_HEIGHT/2 - camYLogical);

         // REQ 1/7: Background is white
         ctx.fillStyle = '#FFFFFF';
         ctx.fillRect(0, 0, EXTENDED_WIDTH, BASE_HEIGHT);

         // 2. Draw Ground Base
         const groundYLogical = BASE_HEIGHT - P_LOGICAL.GROUND_Y_OFFSET;
         
         // REQ 7: Ground is black
         // Check if ground exists before drawing
        // [GEMINI FIX] Simplified logic. Ground exists if (lava) OR (it's Level 2 or 5).
        const groundExists = (obstacles || []).some(o => o.type === 'lava') || 
                                 currentLevelIndex === 1 || 
                                 currentLevelIndex === 4;
        // [GEMINI FIX] Check for lava to prevent drawing black ground
        const lavaExists = (obstacles || []).some(o => o.type === 'lava');

         if(groundExists) { // [GEMINI FIX] Draw black ground on lava levels
             ctx.fillStyle = '#000000';
             ctx.fillRect(0, groundYLogical, EXTENDED_WIDTH, BASE_HEIGHT - groundYLogical);
         }
         
         // 3. Draw Level Elements
         platforms.forEach(plat => plat.draw(ctx));
         enemies.forEach(e => e.draw(ctx));
         collectibles.forEach(col => col.draw(ctx));
         drawDoor(ctx);

         // Player
         player.draw(ctx);

         // Obstacles
         obstacles.forEach(obs => obs.draw(ctx));

         // Particles
         particles.forEach(p => p.draw(ctx));

         ctx.restore();
     }


     // ====================================
     // HUD DRAWING (Fixed Screen Space)
     // ====================================

     // REQ 1: Re-add DPR scaling
     ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

     // REQ 7: Black text
     if (player) {
         ctx.fillStyle = '#000000';
         /* FIX: Changed font to Georgia */
         ctx.font = '20px Georgia';
         ctx.textAlign = 'left';
         ctx.fillText(`LIVES: ${lives > 0 ? lives : 0}`, BASE_WIDTH - 100, 30);
         ctx.fillText(`LEVEL: ${currentLevelIndex < levelData.length ? currentLevelIndex + 1 : levelData.length} / ${levelData.length}`, BASE_WIDTH - 180, 55);
         
         /* [GEMINI FIX] Removed Score and Inventory text per user request */
         // ctx.fillText(`SCORE: ${gameScore}`, 10, 30);
         // ctx.font = '16px Georgia';
         // ctx.fillText(`Rings: ${player.inventory.rings} | Swords: ${player.inventory.swords} | Gems: ${player.inventory.gems || 0}`, 10, 75);
     }
    
     // --- GAME STATE OVERLAYS ---
     if (isPaused) {
         // REQ 7: White overlay
         // FIX: Opaque white background
         ctx.fillStyle = '#FFFFFF';
         ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);

         // REQ 7: Black text
         ctx.fillStyle = '#000000';
         /* FIX: Changed font to Georgia */
         ctx.font = '60px Georgia';
         ctx.textAlign = 'center';

         if (isGameOver) {
             // FIX: Game Over loop
             ctx.fillText('GAME OVER!', BASE_WIDTH / 2, BASE_HEIGHT / 2 - 40);
             /* FIX: Changed font to Georgia */
             ctx.font = '30px Georgia';
             ctx.fillText(`Final Score: ${gameScore}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 20);
             ctx.fillText('Please press any key to return to Title', BASE_WIDTH / 2, BASE_HEIGHT / 2 + 70);
         } else if (currentLevelIndex >= levelData.length) {
             // FIX: Win loop
             ctx.fillText('CAMPAIGN COMPLETE!', BASE_WIDTH / 2, BASE_HEIGHT / 2 - 40);
             /* FIX: Changed font to Georgia */
             ctx.font = '30px Georgia';
             ctx.fillText(`Final Score: ${gameScore}`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 20);
             ctx.fillText('CLICK / PRESS ANY KEY to return to Title', BASE_WIDTH / 2, BASE_HEIGHT / 2 + 70);
         } else {
             // FIX: Title Screen
             ctx.fillText('STRETCHY KING', BASE_WIDTH / 2, BASE_HEIGHT / 2 - 40);
             /* FIX: Changed font to Georgia */
             ctx.font = '30px Georgia';
             ctx.fillText('CLICK / PRESS ANY KEY to Play', BASE_WIDTH / 2, BASE_HEIGHT / 2 + 20);
             ctx.fillText(`Level ${currentLevelIndex + 1} (Start)`, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 70);
         }
     }
    
     // Level transition fade overlay
     if (fadeAlpha > 0 && !isPaused) {
         // REQ 7: White fade
         ctx.fillStyle = `rgba(255, 255, 255, ${fadeAlpha})`;
         ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
     }


     // Debug info
     if (window.isDebug && player) {
         /* FIX: Changed font to Georgia */
         ctx.font = '12px Georgia';
         ctx.fillStyle = '#000000'; // REQ 7
         ctx.textAlign = 'right';
         ctx.fillText(`FPS: ${(1/((performance.now() - lastTime) / 1000)).toFixed(1)}`, BASE_WIDTH - 10, 10);
         ctx.fillText(`Grounded: ${player.isGrounded} Jumps: ${player.jumpsLeft}`, BASE_WIDTH - 10, 70);
         ctx.fillText(`W: ${player.width.toFixed(1)} H: ${player.height.toFixed(1)}`, BASE_WIDTH - 10, 85);
         ctx.fillText(`Y: ${player.y.toFixed(1)} VY: ${player.vy.toFixed(1)}`, BASE_WIDTH - 10, 100);
     }
}

function startPlaying() {
     if (isPaused) {
         // REQ 9: Init audio on first interaction
         if (!soundsLoaded) {
             initAudio();
         }
         
         // FIX: Reworked logic to return to title screen after Game Over/Win
         if (isGameOver || currentLevelIndex >= levelData.length) {
             isGameOver = false;
             gameScore = 0;
             lives = 10; // FIX: Reset lives to 10
             currentLevelIndex = 0;
             localStorage.removeItem(STORAGE_KEY);
             
             const initialSaveData = loadSave();
             
             // Re-initialize player
             player = new StretchyKing({
                 x: levelData[0].playerX,
                 y: GAME_GROUND_Y - (PLAYER_H_BASE * initialSaveData.playerSize),
                 inventory: initialSaveData.inventory,
                 playerSize: initialSaveData.playerSize
             });
             loadLevel(0);
             // NOTE: Do NOT set isPaused = false. This returns to the title screen.
             // The next keypress will call startPlaying() again and fall into the 'else' block.
         } else {
             // This is a regular unpause
             isPaused = false;
         }
     }
}


// Initializers
function init() {
     const savedData = loadSave();
    
     P.GROUND_Y = GAME_GROUND_Y;
     P.VX_MAX = P_LOGICAL.VX_MAX;
     P.JUMP_IMPULSE = P_LOGICAL.JUMP_IMPULSE_BASE;

     // REQ 1: Set fixed canvas size, WITH DPR
     canvas.width = BASE_WIDTH * DPR;
     canvas.height = BASE_HEIGHT * DPR;
     // REQ 1: Set CSS size to fixed 960x540
     canvas.style.width = BASE_WIDTH + 'px';
     canvas.style.height = BASE_HEIGHT + 'px';

    
     const initialPlayerSize = savedData.playerSize || 1.0;
     const initialLevelData = levelData[0];
     const initialHeight = PLAYER_H_BASE * initialPlayerSize;

     player = new StretchyKing({
         x: initialLevelData.playerX,
         y: GAME_GROUND_Y - initialHeight,
         inventory: savedData.inventory,
         playerSize: initialPlayerSize
     });

     loadLevel(0);
     lives = savedData.lives;
     gameScore = savedData.score;

     setupInput();
     setupTouch();

     requestAnimationFrame(gameLoop);

     canvas.addEventListener('click', startPlaying);
     document.addEventListener('keydown', (e) => {
         if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'a', 'd', 'w', 's', 'b', 'v', 'e', 'x'].includes(e.key.toLowerCase())) {
            e.preventDefault();
         }
         
         // This handles the "press any key to start/restart"
         if (isPaused && e.key.toLowerCase() !== 'p' && e.key !== '`') {
             startPlaying();
         }
     });

}

// REQ 5: All controls setup
function setupInput() {
     document.addEventListener('keydown', (e) => {
         if (isPaused) {
             if (e.key.toLowerCase() === 'p') { startPlaying(); }
             return;
         }

         // REQ 9: Init audio on first keydown
         if (!soundsLoaded) initAudio();

         if (checkKonami(e.code)) return;

         // REQ 5: Left
         if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left = true;
         // REQ 5: Right
         if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right = true;
         // REQ 5: Jump
         if (e.key === ' ' || e.key.toLowerCase() === 'w' || e.key === 'ArrowUp') input.jump = true;
         // REQ 5: Glide
         if (e.key.toLowerCase() === 's' || e.key === 'ArrowDown') input.down = true;
         
         // This 'up' is for the old powerup, 'jump' handles jump
         if (e.key === 'ArrowUp') input.up = true;
         
         // REQ 5: Grow
         if (e.key.toLowerCase() === 'b' && !input.sizeChangeUp) input.sizeChangeUp = true;
         // REQ 5: Shrink
         if (e.key.toLowerCase() === 'v' && !input.sizeChangeDown) input.sizeChangeDown = true;
         
         // REQ 5: Attack
         if (e.key.toLowerCase() === 'e' || e.key.toLowerCase() === 'x') input.action = true;

         if (e.key.toLowerCase() === 'p') isPaused = !isPaused;
         if (e.key === '`') window.isDebug = !window.isDebug;
     });

     document.addEventListener('keyup', (e) => {
         if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') input.left = false;
         if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') input.right = false;

         if (e.key === ' ' || e.key.toLowerCase() === 'w' || e.key === 'ArrowUp') input.jump = false;
         
         if (e.key === 'ArrowUp') input.up = false;
         if (e.key.toLowerCase() === 's' || e.key === 'ArrowDown') input.down = false;
         
         if (e.key.toLowerCase() === 'e' || e.key.toLowerCase() === 'x') input.action = false;
    });
}

function setupTouch() {
    const handleTouch = (e) => {
         if (isPaused) {
             startPlaying();
             e.preventDefault();
             return;
         }

         // REQ 9: Init audio on first touch
         if (!soundsLoaded) initAudio();

         // Reset continuous inputs
         input.left = false;
         input.right = false;
         input.jump = false;
         input.action = false;
         input.down = false;
         input.up = false;

         for (let touch of e.touches) {
             const el = document.elementFromPoint(touch.clientX, touch.clientY);
             if (el) {
                 switch (el.id) {
                     case 'touch-left':
                           input.left = true;
                           break;
                       case 'touch-right':
                           input.right = true;
                           break;
                       case 'touch-jump':
                           input.jump = true;
                           input.up = true; // For old powerup
                           break;
                       case 'touch-action':
                           input.action = true;
                           break;
                 }
             }
         }
        
         e.preventDefault();
    };
    
    document.addEventListener('touchstart', handleTouch, { passive: false });
    document.addEventListener('touchmove', handleTouch, { passive: false });
    document.addEventListener('touchend', handleTouch, { passive: false });
    document.addEventListener('touchcancel', handleTouch, { passive: false });
}

function gameLoop(time) {
    const dt = (time - lastTime) / 1000 || 0;
    lastTime = time;

    update(dt);
    draw();

    requestAnimationFrame(gameLoop);
}

document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
